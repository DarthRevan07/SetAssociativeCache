$date
	Sun Nov 13 23:29:45 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Main_new_tb $end
$scope module uut $end
$var reg 1 ! hitmiss $end
$var reg 5 " hittag [4:0] $end
$var reg 28 # memoryAddress [27:0] $end
$var reg 1 $ readEnable $end
$var reg 5 % tagNumber [4:0] $end
$var reg 7 & temp [6:0] $end
$var reg 14 ' writeData [13:0] $end
$var reg 1 ( writeEnable $end
$var integer 32 ) addressToMemory [31:0] $end
$var integer 32 * blockNumberInMemory [31:0] $end
$var integer 32 + data [31:0] $end
$var integer 32 , empty [31:0] $end
$var integer 32 - file [31:0] $end
$var integer 32 . hitrate [31:0] $end
$var integer 32 / missmaxcount [31:0] $end
$var integer 32 0 offset [31:0] $end
$var integer 32 1 readhit [31:0] $end
$var integer 32 2 readmiss [31:0] $end
$var integer 32 3 set_number [31:0] $end
$var integer 32 4 statusi [31:0] $end
$var integer 32 5 way_number [31:0] $end
$var integer 32 6 way_number_temp [31:0] $end
$var integer 32 7 writehit [31:0] $end
$var integer 32 8 writemiss [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 9 i [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 : j [31:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 ; k [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop3 $end
$var integer 32 < i [31:0] $end
$scope begin $ivl_for_loop4 $end
$var integer 32 = j [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop5 $end
$var integer 32 > z [31:0] $end
$scope begin $ivl_for_loop10 $end
$var integer 32 ? i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop11 $end
$var integer 32 @ i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop6 $end
$var integer 32 A i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop7 $end
$var integer 32 B i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop8 $end
$var integer 32 C i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop9 $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000 D
b100 C
b100 B
b11111111111111111111111111111111 A
b100 @
b10000 ?
b1000001100 >
b10000 =
b100000000 <
b10000 ;
b100 :
b1000 9
b1010110 8
b101100101 7
b10 6
b10 5
b11111111111111111111111111111111 4
b110 3
b1000011 2
b1110 1
b11 0
b111 /
b1000110 .
b10000000000000000000000000000011 -
b11111111111111111111111111111111 ,
b111000010100 +
b11110 *
b1001110 )
1(
b111000010100 '
b1101001 &
b11 %
0$
b1111110000010001000111100011 #
b11 "
1!
$end
#10
